<h1 align="center">ttools/build</h1>

<div align="center">

  [![en](https://img.shields.io/badge/lang-en-blue.svg)](https://github.com/TuleshDev/ttools/blob/main/build/README.md)
  [![ru](https://img.shields.io/badge/lang-ru-red.svg)](https://github.com/TuleshDev/ttools/blob/main/build/README.ru.md)

</div>

## Общая информация

Это инструмент, позволяющий построить проект с помощью копирования из разных источников файлов и папок и внесения изменений. Точнее, в данном проекте представлен набор классов, из которых можно построить скрипт на Python, выполняющий копирование определённых файлов и папок из различных источников.

Фактически всё сводится к копированию. Сначала производится копирование из одной папки, затем из другой и так далее, из нескольких папок. Файлы из каждой следующей папки-источника перезаписывают файлы из предыдущей папки-источника, в случае совпадения файлов. За счёт того, что совпадающие файлы перезаписываются, а количество папок-источников не ограничено, можно добиться внесения изменений там, где это потребуется.

Источниками являются папки с файлами и папками, которые следовало бы копировать. Например, папками-источниками могут быть копии разных проектов.

Для того, чтобы придать этому определённую структурированность, надо договориться о некоторых допущениях, которые будут соблюдаться в дальнейшем. Будем считать, что все папки-источники собраны в одном месте - произвольной папке на диске. Назовём её **папкой источником**. Копирование производится в определённую папку - **папку назначения**. Сам скрипт назовём **скриптом построения**.

Предполагается, что до запуска *скрипта построения* *папка назначения* пуста. Для её очищения, можно написать скрипт, который будет очищать эту папку. Естественно, после запуска *скрипта построения* в *папке назначения* будут содержаться скопированные файлы и папки - это и есть результат построения. Название, **результат построения**, закрепим за этим содержимым *папки назначения*. Вообще, все вводимые мной названия я буду стараться выделять **полужирным шрифтом** при введении названия, дальнейшие появления этого названия буду выделять *курсивом* для выделения из общего текста. А названий придётся ввести определённое количество для того, чтобы был набор терминов, которые можно использовать в процессе изложения.

В *папке источнике* можно разместить копии нескольких проектов. Это могут быть копии собственных проектов или копии проектов из GitHub. Каждый из этих проектов надо разместить в отдельной папке и в ней необходимо разместить конфигурационный файл, который указывает, какие файлы и папки следует копировать в процессе получения *результата построения*. Подробнее о конфигурационных файлах будет сказано далее, пока же можно упомянуть, что это файлы в формате JSON.

> **Замечание**: я говорю именно о копиях проектов потому, что *папка источник* носит чисто служебный характер, она нужна только для получения *результата построения*, а разрабатываемые собственные проекты лучше размещать в другом месте.

Вообще, данный проект можно использовать для копирования произвольных файлов и папок. Но довольно удобно использовать его для копирование программного кода.

Если говорить о программном коде, то кроме упомянутых проектов, источников для копирования, можно создать дополнительную папку. В ней можно разместить код, изменяющий и дополняющий коды копируемых проектов. В этой папке также надо разместить конфигурационный файл, который определяет, что и как следует копировать. Естественно, код из этой папки следует копировать в последнюю очередь. Более точно, сценарии использования описаны в следующем разделе.

## Возможные сценарии использования

Вот несколько сценариев, в которых этот проект может быть полезен:
- в *папке источнике* имеется копия проекта из GitHub, хотелось бы скопировать файлы проекта в *папку назначения* и дополнить проект некоторым количеством новых файлов (и папок), модифицирующих функциональность этого проекта. Эти дополнительные файлы (и папки) можно разместить в отдельной подпапке *папки источника*, с учетом их размещения в проекте из GitHub, и тогда получается, что у нас имеется два источника для копирования - это папка с копией основного проекта из GitHub и папка с дополнительными файлами (и папками). При этом важен порядок копирования, поэтому сначала копируется содержимое первой папки, а затем второй;
- имеются копии нескольких проектов из GitHub в *папке источнике* и в ней же есть папка с дополнительными файлами (и папками). Хотелось бы скопировать содержимое всех этих проектов из GitHub в *папку назначения* и добавить в неё дополнительные файлы (и папки). Опять же, важен порядок копирования. При этом, папка с дополнительными файлами (и папками) должна копироваться последней, чтобы файлы из неё накрывали одноимённые файлы из GitHub и изменяли их содержимое;
- имеется код собственного, разрабатываемого проекта, но он разбит на папки по какому-то принципу, удобному разработчику. Например, это могут быть такие папки: папка основного кода, общего для этого и другого проекта, папка кода, специфичного для этого проекта, папка с дополнительными модулями или плагинами, которые должны появиться в *папке назначения* или наоборот, их не должно быть там, в зависимости от потребностей разработчика или пользователя проекта, папка с кодом, предназначенным для конфигурации проекта, папка с документацией. Если разработчик довольно часто перестраивает и тестирует проект, а плагины и документация занимают много места на диске или существенно увеличивают время работы *скрипта построения*, то он на время может не включать уже отлаженные плагины и готовую документацию в *результат построения* в *папке назначения*. При этом, все плагины и документация будут включены в окончательный *результат построения*, предназначенный для продакшена.

Это только некоторые из возможных сценариев применения данного проекта.

## Структура папок

Структура папок и их имена в *папке источнике* могут быть произвольными, например такими:

```console
Origin/
Changes/
Plugins/
Docs/
```

В данном случае, в папке `Origin` может располагаться копия проекта из GitHub, в папке `Changes` - файлы и папки с кодом, модифицирующим оригинальный проект, в папке `Plugins` - код, изменяющий работу плагинов из папки `Origin`, или код новых плагинов, в папке `Docs` - документация.

## Порядок построения

Имеет значение, в каком порядке файлы и папки из папок проектов будут копироваться, так как в разных проектах могут быть файлы с одинаковыми именами и копия файла из одного проекта будет перекрывать копию из другого проекта. Порядок копирования будет определяться названиями папок проектов и естественным упорядочением этих названий в алфавитном порядке.

Пользователю предоставлена возможность самому именовать папки проектов так, как он хочет. Но при этом, надо учитывать, что перед копированием папки упорядочиваются в алфавитном порядке.

Указанные выше имена папок можно изменить следующим образом, чтобы их содержимое копировалось в том порядке, в котором они перечислены выше:

```console
1_Origin/
2_Changes/
3_Plugins/
4_Docs/
```

## Как это работает?

Как упоминалось в начале, этот проект содержит набор классов на Python, из которых можно построить скрипт, выполняющий копирование. В дальнейшем, будем называть его **скриптом построения**. Скрипт может иметь любое имя, для определённости, назовём его `build.py`. Пример этого скрипта содержится в папке `build` репозитория. Он называется `"build (Example).py"`. Вот его содержимое:

<!-- snippet:1424691a:build/build (Example).py:python -->
> [Из коммита `1424691a`, файл `build/build (Example).py`](https://github.com/TuleshDev/ttools/blob/1424691a/build/build (Example).py)

```python
1	import sys
2	sys.path.append('./0_Build/ttools/build')
3	sys.pycache_prefix='C:/__pycache__'
4	
5	from BuildHelper import BuildHelper
6	
7	
8	def main():
9	    isBuildIncluded = True
10	
11	    buildHelper = BuildHelper(__file__, isBuildIncluded)
12	    error = buildHelper.run()
13	    return error
14	
15	
16	if __name__ == '__main__':
17	    main()
```
<!-- snippet:end -->

Папку, в которой находится скрипт `build.py`, назовём **папкой построения**. Этой папкой может быть любая папка. *Папка построения* может совпадать с *папкой источника*, если скрипт `build.py` лежит в *папке источнике*.

В скрипте `build.py`, вызывается метод `run()` объекта класса `BuildHelper`. Этот класс, а также его родительский класс `BasePaths` являются вспомогательными и тесно связаны с *результатом построения* и поэтому должны быть написаны индивидуально под нужды *результата построения* и расположены в *папке построения*. Класс `BuildHelper` определяет то, как будут использоваться классы инструмента `ttools/build` в процессе копирования, а класс `BasePaths` предназначен для настройки используемых путей. Классы `BasePaths` и `BuildHelper` опираются на набор классов, определённых в папке `ttools/build`. В этой папке содержатся файлы `"BasePaths (Example).py"` и `"BuildHelper (Example).py"`, в которых определены примеры классов `BasePaths` и `BuildHelper` соответственно.

Вот как выглядит файл `"BasePaths (Example).py"`:

<!-- snippet:1424691a:build/BasePaths (Example).py:python -->
> [Из коммита `1424691a`, файл `build/BasePaths (Example).py`](https://github.com/TuleshDev/ttools/blob/1424691a/build/BasePaths (Example).py)

```python
1	import os.path
2	
3	from BaseTools import BaseTools
4	
5	
6	class BasePaths:
7	
8	    def __init__(self, file):
9	        self.rootDir = os.path.dirname(file)
10	        rootDirName = os.path.basename(self.rootDir)
11	
12	        sourceFragment = ''
13	        path = os.path.join(self.rootDir, 'source.txt')
14	        if os.path.exists(path):
15	            with open(path, 'r') as read_file:
16	                sourceFragment = read_file.readline().replace('\n', '')
17	
18	        if sourceFragment == '':
19	            self.sourceDir = os.path.join(self.rootDir, 'sourceDir')
20	        else:
21	            self.sourceDir = BaseTools.buildPath(self.rootDir, sourceFragment)
22	
23	        destFragment = ''
24	        path = os.path.join(self.rootDir, 'destination.txt')
25	        if os.path.exists(path):
26	            with open(path, 'r') as read_file:
27	                destFragment = read_file.readline().replace('\n', '')
28	
29	        if destFragment == '':
30	            self.destDir = os.path.join(self.rootDir, 'destDir')
31	        else:
32	            destFragment = BaseTools.buildPath(self.rootDir, destFragment)
33	            self.destDir = destFragment
34	
35	        self.version = ''
36	
37	        self.scriptName = os.path.basename(file)
38	        position = self.scriptName.rfind('.py')
39	        if position != -1:
40	            self.scriptName = self.scriptName[:position]
41	
42	        self.scriptDescriptor1 = rootDirName + '.' + self.scriptName
43	        self.scriptDescriptor2 = self.scriptDescriptor1
```
<!-- snippet:end -->

В определении класса `BasePaths` из этого файла считываются значения, записанные в файлах `source.txt`, `destination.txt`, `version.txt`, которые должны находиться в корне *папки построения*. Эти значения позволяют определить атрибуты класса для *папки источника*, *папки назначения* и номера версии *результата построения*. Также, в классе определяется несколько дополнительных атрибутов, в том числе `scriptName`, `scriptDescriptor1` и `scriptDescriptor2`.

В некоторых случаях версия *результата построения* является важным параметром и в таком случае, её надо как-то использовать в формировании атрибута `self.destDir` класса `BasePaths` для *папки назначения*, чтобы учитывать куда копировать в зависимости от номера версии. Это можно сделать, например, так:

```python
class BasePaths:

    def __init__(self, file):
        self.rootDir = os.path.dirname(file)
        rootDirName = os.path.basename(self.rootDir)

        ...

        destFragment = ''
        path = os.path.join(self.rootDir, 'destination.txt')
        if os.path.exists(path):
            with open(path, 'r') as read_file:
                destFragment = read_file.readline().replace('\n', '')

        if destFragment == '':
            self.destDir = os.path.join(self.rootDir, 'destDir')
        else:
            destFragment = BaseTools.buildPath(self.rootDir, destFragment)
            self.destDir = os.path.join(destFragment, rootDirName)

        path = os.path.join(self.rootDir, 'version.txt')
        if os.path.exists(path):
            with open(path, 'r') as read_file2:
                self.version = read_file2.readline().replace('\n', '')
                self.destDir = os.path.join(self.destDir, self.version)
        else:
            self.version = '1'
```

Если же номер версии не важен для *результата построения*, в качестве основы для класса `BasePaths` можно взять пример из файла `"BasePaths (Example).py"`.
